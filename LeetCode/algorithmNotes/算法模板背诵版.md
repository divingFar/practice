# 1.基础算法

## 排序算法
### 快速排序
```java
 public static void quickSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int i = l - 1, j = r + 1, x = nums[l + r >> 1];
        while (i < j) {
            do i++; while (nums[i] < x);//不能取等，会导致
            do j--; while (nums[j] > x);
            if (i < j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        quickSort(nums, l, j);//到这一步时只可能i=j或者i=j+1
        quickSort(nums, j + 1, r);
    }
```

### 归并排序

```java
 public static void mergeSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1, k = 0;
        int[] tmp = new int[r - l + 1];
        while (i <= mid && j <= r) {
            tmp[k++] = nums[i] < nums[j] ? nums[i++] : nums[j++];
        }
        while (i <= mid) {
            tmp[k++] = nums[i++];
        }
        while (j <= r) {
            tmp[k++] = nums[j++];
        }
        for (i = 0; i < tmp.length; i++) nums[i + l] = tmp[i];
    }
```

##  二分

### 整数二分算法模板 

```java
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; // check()判断mid是否满足性质,如果是，答案被划分在了左半区，mid代表了要找的结果，可以理解为有相同数字时这个模板找到左边那个，下一个模板找到了右边那个
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;//// check()判断mid是否满足性质,如果是，答案被划分在了左半区
        else r = mid - 1;
    }
    return l;
}
```

### 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根
```java
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

### 高精度加法 —— 模板题 AcWing 791. 高精度加法
```java
 public static List<Integer> add(List<Integer> A,List<Integer> B )
    {
        if (A.size()<B.size()) return add(B,A);
        int t = 0;
        for (int i = 0; i < A.size(); i ++ )
        {
            t += A.get(i);
            if (i < B.size()) t += B.get(i);
            A.set(i, t % 10);
            t /= 10;
        }
        if (t!=0) A.add(t);
        return A;
    }
```

### 高精度减法 —— 模板题 AcWing 792. 高精度减法

```java
public static List<Integer> sub(List<Integer> A,List<Integer> B)
    {
        if(!cmp(A,B)) return sub(B,A);
        for(int i = 0,t = 0;i < A.size();i++)
        {
            t = A.get(i) - t;
            if(i < B.size()) t -= B.get(i);
            A.set(i, (t + 10) % 10);
            if(t < 0) t = 1;
            else t = 0;
        }
        //若该数的头为0，则去掉（注意：该数的数学顺序是倒序）
        while(A.size() > 1 && A.get(A.size() - 1) == 0) A.remove(A.size() - 1);
        return A;
    }


```

### 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法

```java
public static List<Integer> mul(List<Integer> A, int B)
{
    int t = 0;
    for(int i = 0;i < A.size();i++)
    {
        t += A.get(i) * B;
        A.set(i, t % 10);
        t /= 10;
    }
    while(t != 0)
    {
        A.add(t % 10);
        t /= 10;
    }
    return A;
}
```

### 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法

```java
static int t = 0;
//从高位往低位除
public static List<Integer> div(List<Integer> A,int B)
{
    for(int i = A.size() - 1;i >= 0 ;i--)
    {
        t = t * 10 + A.get(i);
        A.set(i, t / B);
        t %= B;
    }
    while(A.size() > 1 && A.get(A.size() - 1) == 0) A.remove(A.size() - 1);
    return A;
}
```

### 一维前缀和 —— 模板题 AcWing 795. 前缀和

  S[i] = a[1] + a[2] + ... a[i]
  a[l] + ... + a[r] = S[r] - S[l - 1]

### 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和

S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：

```java
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

### 一维差分 —— 模板题 AcWing 797. 差分

给区间[l, r]中的每个数加上c：

```java
B[l] += c, B[r + 1] -= c
```

### 二维差分 —— 模板题 AcWing 798. 差分矩阵

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：

```java
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

### 位运算 —— 模板题 AcWing 801. 二进制中1的个数

求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n

### 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和

for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
    }
    常见问题分类：
        (1) 对于一个序列，用两个指针维护一段区间
        (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
    离散化 —— 模板题 AcWing 802. 区间和
    vector<int> alls; // 存储所有待离散化的值
    sort(alls.begin(), alls.end()); // 将所有值排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素
// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}

区间合并 —— 模板题 AcWing 803. 区间合并
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());
    
    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);
    
    if (st != -2e9) res.push_back({st, ed});
    
    segs = res;
}

高精度
前缀和与差分
双指针算法
位运算
离散化
区间合并
数据结构 —— 代码模板链接 常用代码模板2——数据结构

链表与邻接表：树与图的存储
栈与队列：单调队列、单调栈
kmp
Trie
并查集
堆
Hash表
C++ STL使用技巧
搜索与图论 —— 代码模板链接 常用代码模板3——搜索与图论

DFS与BFS
树与图的遍历：拓扑排序
最短路
最小生成树
二分图：染色法、匈牙利算法
数学知识 —— 代码模板链接 常用代码模板4——数学知识

质数
约数
欧拉函数
快速幂
扩展欧几里得算法
中国剩余定理
高斯消元
组合计数
容斥原理
简单博弈论
动态规划

背包问题
线性DP
区间DP
计数类DP
数位统计DP
状态压缩DP
树形DP
记忆化搜索
贪心

时空复杂度分析

